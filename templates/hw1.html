<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Server Penetration Simulation</title>
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='style.css') }}">
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            margin: 20px;
        }
        #theory-questions {
            margin-top: 20px;
            border: 1px solid #ccc;
            padding: 15px;
            background-color: #ffffff;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            text-align: left; /* Left-aligned text */
        }
        h2 {
            color: #333;
            margin-bottom: 10px;
        }
        p {
            margin: 10px 0;
            line-height: 1.5;
        }
        .math {
            font-family: 'Courier New', Courier, monospace;
            background-color: #e8f0fe;
            padding: 5px;
            border: 1px solid #2196F3;
            display: inline-block;
            white-space: nowrap; /* Prevent line breaks in math */
        }
        #controls {
            margin: 20px 0;
            padding: 10px;
            background-color: #f1f1f1;
            border-radius: 5px;
        }
        canvas {
            border: 1px solid #ccc;
            background-color: white;
        }
    </style>
</head>
<body>
    <h1>Server Penetration Simulation</h1>

    <div id="theory-questions">
        <h2>1. Basic Notions in Statistics</h2>
        <p>
            In statistics, fundamental concepts provide the basis for analyzing data effectively:
        </p>
        <h3>Population</h3>
        <p>
            A <strong>population</strong> refers to the entire set of items or individuals that we wish to study. It can be finite (e.g., all students in a school) or infinite (e.g., all possible outcomes of a random process).
        </p>

        <h3>Statistical Units</h3>
        <p>
            Each item within a population is termed a <strong>statistical unit</strong>. These units can vary based on the context of the study; for example, in a survey measuring household income, each household acts as a statistical unit.
        </p>

        <h3>Distribution</h3>
        <p>
            The <strong>distribution</strong> of a variable describes how values are spread across the population. Common types of distributions include normal, binomial, and uniform distributions. Graphical representations, such as histograms, help illustrate the frequency of different values within the data.
        </p>

        <h2>2. Notion of Average</h2>
        <p>
            The <strong>average</strong> (or mean) is a central measure used to summarize a set of data. It is calculated as follows:
        </p>
        <p class="math">
            Mean (μ) = &Sigma;<sub>i=1</sub><sup>n</sup> x<sub>i</sub> / n
        </p>
        <p>
            where <em>μ</em> is the mean, <em>x<sub>i</sub></em> represents each value in the dataset, and <em>n</em> is the total number of values.
        </p>

        <h3>Computational Problems with Floating Point Representation</h3>
        <p>
            When performing calculations with floating-point numbers, certain issues can arise:
        </p>
        <ul>
            <li><strong>Rounding Errors:</strong> Inexact representation of decimal numbers can lead to small discrepancies.</li>
            <li><strong>Catastrophic Cancellation:</strong> This occurs when subtracting two nearly equal numbers, resulting in a significant loss of precision. For instance, in the calculation of <em>a = 1.0001</em> and <em>b = 1.0000</em>, the result <em>a - b</em> is <em>0.0001</em>, but if both values are rounded, the result can be inaccurately represented.</li>
        </ul>
        
        <h3>Numerical Solutions and Knuth's Approach</h3>
        <p>
            Donald Knuth emphasizes the importance of using robust numerical methods to mitigate these computational problems. Techniques such as:
        </p>
        <ul>
            <li><strong>Arbitrary Precision Arithmetic:</strong> This allows calculations to maintain a higher level of accuracy beyond standard floating-point limitations.</li>
            <li><strong>Numerical Algorithms:</strong> Careful selection of algorithms that minimize error propagation and maximize precision are crucial for obtaining reliable results.</li>
        </ul>
    </div>

    <div id="controls">
        <label for="servers">Number of Servers (n): </label>
        <input type="number" id="servers" value="50" min="1" max="100" step="1">
        <label for="attackers">Number of Attackers (m): </label>
        <input type="number" id="attackers" value="100" min="1" max="200" step="1">
        <label for="probability">Penetration Probability (p): </label>
        <input type="number" id="probability" value="0.7" min="0" max="1" step="0.01">
        <button id="simulate">Run Simulation</button>
        <button id="downloadBtn" style="display: none;">Download Image</button>
    </div>

    <canvas id="canvas" width="800" height="600"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const simulateButton = document.getElementById('simulate');
        const downloadButton = document.getElementById('downloadBtn');

        // Simulate attacks
        function simulatePenetration(n, m, p) {
            const penetrations = Array.from({ length: m }, () => Array(n).fill(false));
            const penetrationLevels = Array(m).fill(0);
            
            // Simulate attacks
            for (let i = 0; i < m; i++) {
                let level = 0;
                for (let j = 0; j < n; j++) {
                    penetrations[i][j] = Math.random() < p;
                    if (penetrations[i][j]) {
                        level++;
                    }
                }
                penetrationLevels[i] = level;
            }

            // Count penetration levels
            const levelCounts = Array(n + 1).fill(0);
            penetrationLevels.forEach(level => {
                levelCounts[level]++;
            });

            // Smooth the counts using a moving average
            const smoothedCounts = Array(n + 1).fill(0);
            const windowSize = 3;
            for (let i = 0; i <= n; i++) {
                const start = Math.max(0, i - Math.floor(windowSize / 2));
                const end = Math.min(n, i + Math.floor(windowSize / 2));
                const sum = levelCounts.slice(start, end + 1).reduce((a, b) => a + b, 0);
                smoothedCounts[i] = sum / (end - start + 1);
            }

            return { penetrations, smoothedCounts };
        }

        // Draw the grid and penetration lines
        function drawSimulation(penetrations, smoothedCounts, n, m) {
            const width = canvas.width;
            const height = canvas.height;
            const serverWidth = width * 3 / 4 / n;

            // Clear the canvas and fill background
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = "white";
            ctx.fillRect(0, 0, width, height);

            // Draw the grid
            ctx.strokeStyle = "lightgray";
            for (let j = 0; j < n; j++) {
                const newX = (j + 1) * serverWidth;
                ctx.beginPath();
                ctx.moveTo(newX, 0);
                ctx.lineTo(newX, height);
                ctx.stroke();
            }
            for (let y = height - 20; y >= 0; y -= 10) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // Draw each attacker's path
            for (let i = 0; i < m; i++) {
                const randomColor = `rgb(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255})`;
                ctx.strokeStyle = randomColor;

                let x = 0;
                let y = height - 20;
                for (let j = 0; j < n; j++) {
                    const newX = (j + 1) * serverWidth;
                    const newY = y - (penetrations[i][j] ? 10 : 0); // Jump if penetration occurs
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(newX, newY);
                    ctx.stroke();
                    x = newX;
                    y = newY;
                }
            }

            // Draw vertical line to separate attackers from distribution wave
            ctx.strokeStyle = "black";
            const endLine = (width * 3 / 4) - 50;
            ctx.beginPath();
            ctx.moveTo(endLine, 0);
            ctx.lineTo(endLine, height);
            ctx.stroke();

            // Draw the distribution wave
            ctx.strokeStyle = "red";
            ctx.lineWidth = 2;
            const waveWidth = width - endLine;
            const maxCount = Math.max(...smoothedCounts);

            let prevX = endLine;
            let prevY = height;
            for (let i = 0; i <= n; i++) {
                const y = height - i * (height / (n + 1));
                const x = endLine + (smoothedCounts[i] / maxCount) * (waveWidth - 40);
                ctx.beginPath();
                ctx.moveTo(prevX, prevY);
                ctx.lineTo(x, y);
                ctx.stroke();
                prevX = x;
                prevY = y;
            }

            // Restore line width
            ctx.lineWidth = 1;
        }

        // Function to run the simulation when the button is clicked
        simulateButton.addEventListener('click', function() {
            const n = parseInt(document.getElementById('servers').value);
            const m = parseInt(document.getElementById('attackers').value);
            const p = parseFloat(document.getElementById('probability').value);

            // Run the simulation
            const { penetrations, smoothedCounts } = simulatePenetration(n, m, p);

            // Draw the simulation
            drawSimulation(penetrations, smoothedCounts, n, m);

            // Show the download button
            downloadButton.style.display = 'inline-block';
        });

        // Function to download the canvas as an image
        downloadButton.addEventListener('click', function() {
            const link = document.createElement('a');
            link.download = 'simulation.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        });
    </script>
</body>
</html>
