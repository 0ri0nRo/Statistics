<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Computational Problems with Floating Point Representation</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #f9f9f9;
            color: #333;
        }

        h1 {
            color: #0056b3;
            border-bottom: 2px solid #0056b3;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        h2 {
            color: #003366;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        h3 {
            color: #003366;
            margin-top: 15px;
        }

        p {
            margin: 10px 0;
            text-align: justify;
        }

        code {
            background-color: #e0e0e0;
            padding: 2px 5px;
            border-radius: 3px;
        }

        .example {
            background-color: #e8f0fe;
            padding: 10px;
            border-left: 5px solid #2196F3;
            margin: 10px 0;
            border-radius: 5px;
        }

        pre {
            background-color: #e0e0e0;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
        }

        ul {
            margin: 10px 0 10px 20px;
        }

        li {
            margin-bottom: 5px;
        }
    </style>
</head>

<body>
    <h1>Computational Problems with Floating Point Representation</h1>
    <p>Floating point representation is a way to represent real numbers in computers, allowing for a wide range of values by using a format that includes a fraction (the significand or mantissa) and an exponent. However, this representation can lead to several computational problems, especially when dealing with very large or very small numbers. Below are some key issues associated with floating point representation:</p>

    <h2>1. Precision Limitations</h2>
    <p>Floating point numbers have a limited precision due to their finite representation. This means that not all real numbers can be accurately represented. For example, numbers like <code>0.1</code> or <code>0.2</code> cannot be represented precisely in binary floating-point format. As a result, small rounding errors can accumulate in calculations.</p>
    <div class="example">
        <strong>Example:</strong>
        <p>The decimal number <code>0.1</code> is represented in binary floating point as approximately <code>0.1000000000000000055511151231257827021181583404541015625</code>, which is slightly greater than <code>0.1</code>. This discrepancy can cause issues in numerical computations.</p>
    </div>

    <h2>2. Rounding Errors</h2>
    <p>When performing arithmetic operations on floating point numbers, rounding errors can occur due to the limited number of bits used for representation. These errors can lead to unexpected results, especially in iterative calculations or algorithms that require high precision.</p>
    <div class="example">
        <strong>Example:</strong>
        <p>Consider the operation <code>x = 1.0 - 0.9</code>. In an ideal world, this would yield <code>x = 0.1</code>. However, due to floating point representation, the result may be slightly less than <code>0.1</code>, resulting in <code>x &approx; 0.09999999999999998</code>.</p>
    </div>

    <h2>3. Catastrophic Cancellation</h2>
    <p>Catastrophic cancellation occurs when subtracting two nearly equal floating point numbers, leading to a significant loss of precision. This can severely impact the results of computations, especially in algorithms sensitive to small changes in input.</p>
    <div class="example">
        <strong>Example:</strong>
        <p>If we have two numbers:</p>
        <pre>
            a = 1.0000001
            b = 1.0000000
        </pre>
        <p>The calculation <code>c = a - b</code> ideally should give <code>c = 0.0000001</code>. However, if both numbers are rounded in the floating point representation, <code>c</code> may end up being <code>0</code> or a value very close to <code>0</code>, resulting in a significant loss of information.</p>
    </div>

    <h2>4. Overflow and Underflow</h2>
    <h3>Overflow</h3>
    <p>This occurs when a calculation produces a number larger than the maximum representable floating point number. In such cases, the result is often represented as infinity.</p>
    <div class="example">
        <strong>Example:</strong>
        <p>If <code>x = 1.0e308</code> (a very large number) and we perform <code>y = x * 10</code>, <code>y</code> may be represented as infinity.</p>
    </div>

    <h3>Underflow</h3>
    <p>This occurs when a calculation produces a number closer to zero than the smallest representable floating point number. Such numbers are often rounded to zero.</p>
    <div class="example">
        <strong>Example:</strong>
        <p>If we compute <code>y = 1.0e-323 / 10</code>, <code>y</code> may be rounded to zero due to underflow.</p>
    </div>

    <h2>5. Numerical Instability</h2>
    <p>Some algorithms are numerically unstable, meaning that small changes in input can lead to large changes in output. This can be exacerbated by the limitations of floating point representation. Such instability is particularly common in algorithms that involve subtraction of similar numbers, division by small numbers, or iterative processes.</p>

    <h2>Addressing Floating Point Issues</h2>
    <p>To mitigate the problems associated with floating point representation, consider the following strategies:</p>
    <ul>
        <li><strong>Use Higher Precision:</strong> Utilize data types that offer greater precision, such as double precision (64 bits) instead of single precision (32 bits) when necessary.</li>
        <li><strong>Numerical Methods:</strong> Employ numerical algorithms that are designed to minimize error propagation and improve stability. For instance, using Kahan summation can help reduce rounding errors in summation.</li>
        <li><strong>Avoid Catastrophic Cancellation:</strong> Rearrange calculations to minimize the subtraction of nearly equal numbers. If subtraction is unavoidable, consider using alternative formulations that are less sensitive to this problem.</li>
        <li><strong>Error Analysis:</strong> Conduct sensitivity analysis on algorithms to understand how floating point errors affect the final results. This can help in selecting appropriate algorithms based on their stability.</li>
    </ul>

    <h3>Numerical Solutions and Knuth's Approach</h3>
    <p>
        Donald Knuth emphasizes the importance of using robust numerical methods to mitigate these computational problems. Techniques such as:
    </p>
    <ul>
        <li><strong>Arbitrary Precision Arithmetic:</strong> This allows calculations to maintain a higher level of accuracy beyond standard floating-point limitations.</li>
        <li><strong>Numerical Algorithms:</strong> Careful selection of algorithms that minimize error propagation and maximize precision are crucial for obtaining reliable results.</li>
    </ul>

    <div id="controls">
        <label for="servers">Number of Servers (n): </label>
        <input type="number" id="servers" value="50" min="1" max="100" step="1">
        <label for="attackers">Number of Attackers (m): </label>
        <input type="number" id="attackers" value="100" min="1" max="200" step="1">
        <label for="probability">Penetration Probability (p): </label>
        <input type="number" id="probability" value="0.7" min="0" max="1" step="0.01">
        <button id="simulate">Run Simulation</button>
        <button id="downloadBtn" style="display: none;">Download Image</button>
    </div>

    <canvas id="canvas" width="800" height="600"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const simulateButton = document.getElementById('simulate');
        const downloadButton = document.getElementById('downloadBtn');

        // Simulate attacks
        function simulatePenetration(n, m, p) {
            const penetrations = Array.from({ length: m }, () => Array(n).fill(false));
            const penetrationLevels = Array(m).fill(0);
            
            // Simulate attacks
            for (let i = 0; i < m; i++) {
                let level = 0;
                for (let j = 0; j < n; j++) {
                    penetrations[i][j] = Math.random() < p;
                    if (penetrations[i][j]) {
                        level++;
                    }
                }
                penetrationLevels[i] = level;
            }

            // Count penetration levels
            const levelCounts = Array(n + 1).fill(0);
            penetrationLevels.forEach(level => {
                levelCounts[level]++;
            });

            // Smooth the counts using a moving average
            const smoothedCounts = Array(n + 1).fill(0);
            const windowSize = 3;
            for (let i = 0; i <= n; i++) {
                const start = Math.max(0, i - Math.floor(windowSize / 2));
                const end = Math.min(n, i + Math.floor(windowSize / 2));
                const sum = levelCounts.slice(start, end + 1).reduce((a, b) => a + b, 0);
                smoothedCounts[i] = sum / (end - start + 1);
            }

            return { penetrations, smoothedCounts };
        }

        // Draw the grid and penetration lines
        function drawSimulation(penetrations, smoothedCounts, n, m) {
            const width = canvas.width;
            const height = canvas.height;
            const serverWidth = width * 3 / 4 / n;

            // Clear the canvas and fill background
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = "white";
            ctx.fillRect(0, 0, width, height);

            // Draw the grid
            ctx.strokeStyle = "lightgray";
            for (let j = 0; j < n; j++) {
                const newX = (j + 1) * serverWidth;
                ctx.beginPath();
                ctx.moveTo(newX, 0);
                ctx.lineTo(newX, height);
                ctx.stroke();
            }
            for (let y = height - 20; y >= 0; y -= 10) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // Draw each attacker's path
            for (let i = 0; i < m; i++) {
                const randomColor = `rgb(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255})`;
                ctx.strokeStyle = randomColor;

                let x = 0;
                let y = height - 20;
                for (let j = 0; j < n; j++) {
                    const newX = (j + 1) * serverWidth;
                    const newY = y - (penetrations[i][j] ? 10 : 0); // Jump if penetration occurs
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(newX, newY);
                    ctx.stroke();
                    x = newX;
                    y = newY;
                }
            }

            // Draw vertical line to separate attackers from distribution wave
            ctx.strokeStyle = "black";
            const endLine = (width * 3 / 4) - 50;
            ctx.beginPath();
            ctx.moveTo(endLine, 0);
            ctx.lineTo(endLine, height);
            ctx.stroke();

            // Draw the distribution wave
            ctx.strokeStyle = "red";
            ctx.lineWidth = 2;
            const waveWidth = width - endLine;
            const maxCount = Math.max(...smoothedCounts);

            let prevX = endLine;
            let prevY = height;
            for (let i = 0; i <= n; i++) {
                const y = height - i * (height / (n + 1));
                const x = endLine + (smoothedCounts[i] / maxCount) * (waveWidth - 40);
                ctx.beginPath();
                ctx.moveTo(prevX, prevY);
                ctx.lineTo(x, y);
                ctx.stroke();
                prevX = x;
                prevY = y;
            }

            // Restore line width
            ctx.lineWidth = 1;
        }

        // Function to run the simulation when the button is clicked
        simulateButton.addEventListener('click', function() {
            const n = parseInt(document.getElementById('servers').value);
            const m = parseInt(document.getElementById('attackers').value);
            const p = parseFloat(document.getElementById('probability').value);

            // Run the simulation
            const { penetrations, smoothedCounts } = simulatePenetration(n, m, p);

            // Draw the simulation
            drawSimulation(penetrations, smoothedCounts, n, m);

            // Show the download button
            downloadButton.style.display = 'inline-block';
        });

        // Function to download the canvas as an image
        downloadButton.addEventListener('click', function() {
            const link = document.createElement('a');
            link.download = 'simulation.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        });
    </script>
</body>
</html>
