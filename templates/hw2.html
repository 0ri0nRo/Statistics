<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Walk - Multiple Simulations</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #f9f9f9;
            color: #333;
        }

        h1,
        h2,
        h3 {
            color: #003366;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        p {
            margin: 10px 0;
            text-align: justify;
        }

        code {
            background-color: #e0e0e0;
            padding: 2px 5px;
            border-radius: 3px;
        }

        .container {
            margin-top: 20px;
        }

        .input-group {
            margin: 10px 0;
        }

        label {
            display: inline-block;
            width: 150px;
        }

        input[type="number"] {
            width: 80px;
            padding: 5px;
        }

        button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
        }

        button:hover {
            background-color: #45a049;
        }

        #plot-canvas,
        #mean-canvas,
        #variance-canvas {
            margin-top: 20px;
            border: 1px solid #ccc;
        }

        .graph-title {
            background-color: #4A90E2;
            color: white;
            padding: 10px;
            text-align: center;
            border-radius: 5px;
            margin-bottom: 10px;
            font-size: 24px;
            font-weight: bold;
        }
    </style>
</head>

<body>

    <h1>Random Walk - Multiple Simulations</h1>
    <h2>1. Random Walk Simulation with Multiple Paths</h2>
    <p>
        This simulation generates multiple random walks, each path representing a different trajectory.
        The steps of each random walk are drawn from a normal (Gaussian) distribution with mean 0 and variance 1.
    </p>

    <div class="container">
        <div class="input-group">
            <label for="steps">Number of Steps:</label>
            <input type="number" id="steps" value="100" min="10" max="1000">
        </div>
        <div class="input-group">
            <label for="paths">Number of Paths:</label>
            <input type="number" id="paths" value="10" min="1" max="100">
        </div>
        <div class="input-group">
            <label for="time-step">Time Step (Δt):</label>
            <input type="number" id="time-step" value="0.01" min="0.001" max="1" step="0.001">
        </div>
        <div class="input-group">
            <label for="jump-prob">Jump Probability (p):</label>
            <input type="number" id="jump-prob" value="0.1" min="0.0" max="1.0" step="0.01">
        </div>
        <button id="run-simulation">Run Simulation</button>
    </div>

    <div id="results">
        <h2 class="graph-title">Simulation Output</h2>
        <canvas id="plot-canvas" width="800" height="400"></canvas>

        <h2 class="graph-title">Mean Trajectories</h2>
        <canvas id="mean-canvas" width="800" height="400"></canvas>

        <h2 class="graph-title">Variance Trajectories</h2>
        <canvas id="variance-canvas" width="800" height="400"></canvas>

        <button id="downloadBtn" style="display: none;">Download Results</button>
    </div>

    <script>
        const canvas = document.getElementById('plot-canvas');
        const meanCanvas = document.getElementById('mean-canvas');
        const varianceCanvas = document.getElementById('variance-canvas');
        const ctx = canvas.getContext('2d');
        const meanCtx = meanCanvas.getContext('2d');
        const varianceCtx = varianceCanvas.getContext('2d');
        const runSimulationButton = document.getElementById('run-simulation');
        const downloadButton = document.getElementById('downloadBtn');

        // Function to generate random numbers from a Gaussian (normal) distribution
        function gaussianRandom(mean = 0, stdev = 1) {
            let u = 1 - Math.random(); // Subtraction to avoid log(0)
            let v = Math.random();
            let z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
            return z * stdev + mean;
        }

        // Function to simulate jumps
        function randomJump(p) {
            return Math.random() < p ? (Math.random() < 0.5 ? -1 : 1) : 0; // -1 or +1 with probability p
        }

        // Random walk simulation with Gaussian distribution steps for multiple paths
        function simulateRandomWalk(steps, dt, numPaths, jumpProb) {
            let paths = [];
            let means = new Array(steps + 1).fill(0);  // Initialize mean array
            let variances = new Array(steps + 1).fill(0); // Initialize variance array
            let counts = new Array(steps + 1).fill(0); // Count occurrences for mean and variance

            // Simulate multiple random walks
            for (let j = 0; j < numPaths; j++) {
                let path = [0];  // Initial value for each path
                for (let i = 1; i <= steps; i++) {
                    const gaussianStep = gaussianRandom(0, Math.sqrt(dt)); // Step with variance √dt
                    const jump = randomJump(jumpProb); // Step from random jump
                    path.push(path[i - 1] + gaussianStep + jump);

                    // Welford's recursion for mean and variance
                    counts[i]++;
                    const delta = path[i] - means[i];
                    means[i] += delta / counts[i];
                    const delta2 = path[i] - means[i];
                    variances[i] += delta * delta2;
                }
                paths.push(path);
            }

            // Normalize variances
            for (let i = 1; i <= steps; i++) {
                variances[i] = variances[i] / (counts[i] - 1);
            }

            return { paths, means, variances };
        }

        // Draw axes with appropriate margins
        function drawAxes(ctx, width, height, steps, maxY, labelX, labelY) {
            const margin = 40; // Space for axes
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(margin, 0);
            ctx.lineTo(margin, height - margin);
            ctx.lineTo(width, height - margin);
            ctx.stroke();

            ctx.font = '12px Arial';
            ctx.fillStyle = 'black';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // X-axis labels
            for (let i = 0; i <= steps; i += Math.floor(steps / 10)) {
                const x = margin + (i * (width - margin) / steps);
                ctx.fillText(i, x, height - margin + 15);
            }

            // Y-axis labels
            for (let i = -maxY; i <= maxY; i += Math.floor(maxY / 5)) {
                const y = (height - margin) - ((i + maxY) * (height - margin) / (2 * maxY));
                ctx.fillText(i.toFixed(1), margin - 20, y);
            }

            // Axis labels
            ctx.fillText(labelX, width / 2, height - 10);
            ctx.save();
            ctx.translate(margin / 2, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(labelY, 0, 0);
            ctx.restore();
        }

        // Plot the simulation results
        function plotResults(paths, steps) {
            const width = canvas.width;
            const height = canvas.height;
            const stepWidth = (width - 40) / steps; // Space for axes
            const maxY = 10;

            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = "white";
            ctx.fillRect(0, 0, width, height);

            drawAxes(ctx, width, height, steps, maxY, 'Time Step', 'Position');

            // Draw each path
            ctx.strokeStyle = 'blue';
            ctx.lineWidth = 1;

            for (let j = 0; j < paths.length; j++) {
                ctx.beginPath();
                for (let i = 0; i <= steps; i++) {
                    const x = 40 + (i * stepWidth);
                    const y = (height - 40) - (paths[j][i] + maxY) * (height - 40) / (2 * maxY);
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            }
        }

        // Plot the mean trajectory
        function plotMean(mean, steps) {
            const width = meanCanvas.width;
            const height = meanCanvas.height;
            const stepWidth = (width - 40) / steps; // Space for axes
            const maxY = 10;

            meanCtx.clearRect(0, 0, width, height);
            meanCtx.fillStyle = "white";
            meanCtx.fillRect(0, 0, width, height);

            drawAxes(meanCtx, width, height, steps, maxY, 'Time Step', 'Mean Position');

            meanCtx.strokeStyle = 'red';
            meanCtx.lineWidth = 2;

            meanCtx.beginPath();
            for (let i = 0; i <= steps; i++) {
                const x = 40 + (i * stepWidth);
                const y = (height - 40) - (mean[i] + maxY) * (height - 40) / (2 * maxY);
                if (i === 0) {
                    meanCtx.moveTo(x, y);
                } else {
                    meanCtx.lineTo(x, y);
                }
            }
            meanCtx.stroke();
        }

        // Plot the variance trajectory
        function plotVariance(variances, steps) {
            const width = varianceCanvas.width;
            const height = varianceCanvas.height;
            const stepWidth = (width - 40) / steps; // Space for axes
            const maxVariance = 10;

            varianceCtx.clearRect(0, 0, width, height);
            varianceCtx.fillStyle = "white";
            varianceCtx.fillRect(0, 0, width, height);

            drawAxes(varianceCtx, width, height, steps, maxVariance, 'Time Step', 'Variance');

            varianceCtx.strokeStyle = 'green';
            varianceCtx.lineWidth = 2;

            varianceCtx.beginPath();
            for (let i = 0; i <= steps; i++) {
                const x = 40 + (i * stepWidth);
                const y = (height - 40) - (variances[i] * (height - 40) / maxVariance);
                if (i === 0) {
                    varianceCtx.moveTo(x, y);
                } else {
                    varianceCtx.lineTo(x, y);
                }
            }
            varianceCtx.stroke();
        }

        runSimulationButton.addEventListener('click', () => {
            const steps = parseInt(document.getElementById('steps').value);
            const numPaths = parseInt(document.getElementById('paths').value);
            const dt = parseFloat(document.getElementById('time-step').value);
            const jumpProb = parseFloat(document.getElementById('jump-prob').value);

            const { paths, means, variances } = simulateRandomWalk(steps, dt, numPaths, jumpProb);
            plotResults(paths, steps);
            plotMean(means, steps);
            plotVariance(variances, steps);

            downloadButton.style.display = 'inline-block'; // Show download button
        });

        downloadButton.addEventListener('click', () => {
            // Implement download functionality here
            alert('Download feature coming soon!');
        });
    </script>
</body>

</html>
